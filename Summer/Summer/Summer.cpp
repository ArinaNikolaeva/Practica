// Летняя практика.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы. 
// 
// Магическими квадратами называются равносторонние таблицы, все клетки которых заполнены натуральными числами, начиная от 1 (рис. 1.5). 
// Причем эти числа в сумме дают по каждому столбцу, по каждой строке и по диагоналям магического квадрата одно и тоже число (в нашем 
// случае — это число 34). Исходный текст — ЖДУ ВСТРЕЧИ ЮСТАС, при заполнении магического квадрата, вписывается по порядку следования натуральных чисел,
//  например, число 1 заменялось 1 буквой исходного текста (Ж), число 12 — 12 буквой сообщения (С) и т.п. После записи открытого текста 
// содержимое таблицы считывается по строкам в результате чего и получался шифротекст с перестановкой букв.
//

#include<iostream> 
#include<cstdio> 
#include<cmath> 
#include<cstring> 
#include <string>
typedef struct Data Data;
using namespace std;

#define maxn 25 
int m[maxn][maxn];
int matr[maxn][maxn]; //последовательность чисел в маг матрице
struct Data {//хранение данных
    string letter;//шифр       
    int count;
};

//нечетные 3*3 5*5 7*7 и тд 
void OddMagic(int n)                         // Магический квадрат нечетного порядка 
{
    int x = 0, y = n / 2;
    for (int i = 1; i <= n * n; i++)
    {
        m[x][y] = i;
        x--;                                 // По очереди заполняем правый верхний угол 
        y++;
        if (x < 0 && y > n - 1) {
            x = x + 2;
            y = y - 1;
        }     // Превышение по диагонали 

        else if (x < 0)
            x = x + n;                  // Превышение по верхней границе 

        else if (y > n - 1)
            y = y - n;                // Превышение по правой границе 

        else if (m[x][y] != 0) {
            x = x + 2;
            y = y - 1;
        }  // Правый верхний угол заполнен 
    }
}


//чётные 4*4 8*8 и тд. 
void DoubleEvenMagic(int n)                  // Магический квадрат двойного четного порядка 
{
    for (int i = 1, x = 0, y = 0; i <= n * n; i++)      // Последовательно присваиваем начальные значения 
    {
        m[x][y] = i;
        y++;
        if (y > n - 1) {
            x++;
            y -= n;
        }
    }

    for (int i = 0; i < n; i++)                   // Разложите магический квадрат на m * m магических квадратов 4-го порядка и замените диагональные элементы каждого магического квадрата 4-го порядка его дополнением 
        for (int j = 0; j < n; j++)

            if (i % 4 == 0 && j % 4 == 0)             // Левая диагональ 
                for (int k = 0; k < 4; k++)
                    m[i + k][j + k] = (n * n + 1) - m[i + k][j + k];
            else if (i % 4 == 3 && j % 4 == 0)         // Правая диагональ 
                for (int k = 0; k < 4; k++)
                    m[i - k][j + k] = (n * n + 1) - m[i - k][j + k];
}

// таблица 6*6 10*10 
void SingleEvenMagic(int n)                  // Одиночный и даже магический квадрат 
{
    int n0 = n / 2;
    OddMagic(n0);                            // Разложить магический квадрат на 2 * 2 магических квадрата нечетного порядка, вызвать функцию магического квадрата нечетного порядка для заполнения магического квадрата нечетного порядка в верхнем левом углу 

    for (int i = 0; i < n0; i++)
        for (int j = 0; j < n0; j++)
        {
            m[i + n0][j + n0] = m[i][j] + n0 * n0;       // Заполняем нечетный магический квадрат в правом нижнем углу 
            m[i][j + n0] = m[i + n0][j + n0] + n0 * n0;     // Заполняем нечетный магический квадрат в правом верхнем углу 
            m[i + n0][j] = m[i][j + n0] + n0 * n0;       // Заполняем нечетный магический квадрат в левом нижнем углу 
        }
    int k = (n - 2) / 4;                             // Удовлетворение формуле n = 4 * k + 2 
    for (int i = 0; i < n0; i++)
        for (int j = 0; j < k; j++)

            if (i == n0 / 2)
                swap(m[i][i + j], m[i + n0][i + j]);   // Меняем местами k элементов слева направо в середине магического квадрата в верхнем левом углу с соответствующими элементами в магическом квадрате в нижнем левом углу 
            else
                swap(m[i][j], m[i + n0][j]);              // Поменять местами первые k элементов каждой строки верхнего левого магического квадрата, кроме средней строки, с соответствующими элементами в нижнем левом магическом квадрате 

    for (int i = 0; i < n0; i++)
        for (int j = n0 + n0 / 2; j > n0 + n0 / 2 - (k - 1); j--)
            swap(m[i][j], m[i + n0][j]);                   // Меняем местами элементы в столбце k-1 справа налево в
    // среднем столбце магического квадрата в верхнем правом углу с соответствующими элементами в магическом квадрате в правом нижнем углу
}

bool Check(int n)
{
    int cnt = n * (n * n + 1) / 2;                                // Сумма каждой строки, столбца и диагонали 
    for (int i = 0; i < n; i++)
    {
        int sum_row = 0; //строка  
        int sum_line = 0;//столбец 
        for (int j = 0; j < n; j++)
        {
            sum_row += m[i][j];                       // Проверяем строки 
            sum_line += m[j][i];                      // Проверяем столбцы 
        }
        if (sum_row != cnt || sum_line != cnt) //если сумма строк или столбцов не равно одному числу, но всё неверно  
            return false;
    }

    int sum_left = 0; // левая диагональ 
    int sum_right = 0; // правая диагональ  
    for (int i = 0; i < n; i++)
    {
        sum_left += m[i][i];                              // Проверяем левую диагональ 
        sum_right += m[n - i - 1][i];                         // Проверяем правильную диагональ 
    }

    if (sum_left != cnt || sum_right != cnt)  // если суммы диагоналей не равны одному числу, то всё неверно  
        return false;
    return true; // если всё ок то всё ок 
}


void print(int n)                                       // Вывод в формате 
{
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (j == n - 1) {
                printf("%4d\n", m[i][j]);
                matr[i][j] = m[i][j];
            }
            else {
                printf("%4d", m[i][j]);
                matr[i][j] = m[i][j];
            }
        }
    }
}


int main()
{
    setlocale(LC_ALL, "ru");            //руссификатор 

    //==========================================СОЗДАНИЕ ТАБЛИЦЫ==================================== 

    int n;            //размер табл       
    cout << "Введите размер таблицы: ";
    cin >> n;

    if (n < 3) {  // проверяем чтоб таблица  
        cout << "Невозможно" << endl;
        return 0;
    }

    else if (n & 1) { // Вывод магического квадрата нечетного порядка 
        OddMagic(n);
        if (Check(n))
            print(n);
    }
    else if (!(n % 4)) { // Вывод магического квадрата четного порядка 
        DoubleEvenMagic(n);
        if (Check(n))
            print(n);
    }
    else { // Вывод магического квадрата одинарного 
        SingleEvenMagic(n);
        if (Check(n))
            print(n);
    }

    //==========================================ВВОД СЛОВА========================================= 
    string word;
   
    while (size(word) != pow(n, 2)) {
        cout << "Введите слово: ";
        cin >> word;
    }
        
    
    int ch;
    cout << "Введите команду:" << endl << " 0 - Если слово нужно зашифровать" << endl << " 1 - Если слово нужно расшифровать" << endl;
    cin >> ch;
    Data leters[50];

    //======================================ЗАШИФРОВАТЬ============================================
    if (ch == 0) {
        for (int i = 1; i <= size(word); i++) {
            leters[i].letter = word[i - 1];
            leters[i].count = i;
        }

        int c = 1;
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= n; j++) {
                for (int k = 1; k <= pow(n, 2); k++) {
                    if (matr[i][j] == leters[k].count) {
                        cout << leters[k].letter;

                        c += 1;
                        if (c > pow(n, 2)) return 0;
                    }
                }
            }
        }
    }
    //=====================================РАСШИФРОВАТЬ============================================
    if (ch == 1) {
        memset(m, 0, sizeof(m));    //очищаем
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= n; j++) {
                m[i][j] = ch;
                ch += 1;
            }
        }
    }

    for (int i = 1; i <= size(word); i++) {
        leters[i].letter = word[i - 1];
        leters[i].count = i;
    }

    int c = 1;
    for (int i = 0; i <= n; i++) {
        for (int j = 0; j <= n; j++) {
            for (int k = 1; k <= pow(n, 2); k++) {
                if ((n * n) + 1 - matr[i][j] == leters[k].count) {
                    cout << leters[k].letter;
                    c += 1;
                    if (c > pow(n, 2)) return 0;
                }
            }
        }
    }
    return 0;
}